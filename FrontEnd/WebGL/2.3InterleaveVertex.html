<!DOCTYPE HTML>
<html>
	<head>
		<title>Draws a triangle</title>
		<meta charset="utf-8">
		<script src="js/webgl-debug.js"></script>
		<script src="js/shader.js"></script>
		<script id="shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec4 aVertexColor;
			varying vec4 vColor;
			void main(){
				vColor=aVertexColor;
				gl_Position=vec4(aVertexPosition,1.0);
			}
		</script>
		<script id="shader-fs" type="x-shader/x-fragment">
			precision mediump float;

			varying vec4 vColor;
			void main(){
				gl_FragColor = vColor;
			}
		</script>
		<script id="shader-fsc" type="x-shader/x-fragment"></script>
		<script type="text/javascript">
			var gl;
			var canvas;
			var shaderProgram;
			var triangleVertexBuffer;

			

			function setupBuffers(){

				triangleVertexBuffer=gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER,triangleVertexBuffer);

				var triangleVertices=[
					//(x y z) (r g b a)
					0.0,0.5,0.0,255,0,0,255,//v0
					0.5,-0.5,0.0,0,250,6,255,//v1
					-0.5,-0.5,0.0,0,0,255,255//v2
				];

				var nbrOfVertices=3;

				//Calculate how many bytes tha are needed for one vertex element
				var vertexSizeInBytes=3*Float32Array.BYTES_PER_ELEMENT+4*Uint8Array.BYTES_PER_ELEMENT;
				var vertexSizeInFloats=vertexSizeInBytes/Float32Array.BYTES_PER_ELEMENT;
				//Allocate bhte buffer
				var buffer=new ArrayBuffer(nbrOfVertices*vertexSizeInBytes);

				//create 2 view to arrange buffer
				//map the buffer to a float32array
				var positionView=new Float32Array(buffer);

				//map the same buffer to a Uint8Array to access the color
				var colorView=new Uint8Array(buffer);

				//Populate the ArrayBuffer from teh javaScript Array
				var positionOffsetInFloats=0;
				var colorOffsetInBytes=12;
				var k=0;
				for(var i=0;i<nbrOfVertices;i++){
					positionView[positionOffsetInFloats]=triangleVertices[k];
					positionView[positionOffsetInFloats+1]=triangleVertices[k+1];
					positionView[positionOffsetInFloats+2]=triangleVertices[k+2];
					
					colorView[colorOffsetInBytes]=triangleVertices[k+3];
					colorView[colorOffsetInBytes+1]=triangleVertices[k+4];
					colorView[colorOffsetInBytes+2]=triangleVertices[k+5];
					colorView[colorOffsetInBytes+3]=triangleVertices[k+6];

					positionOffsetInFloats+=vertexSizeInFloats;
					colorOffsetInBytes+=vertexSizeInBytes;
					k+=7;
				}
				gl.bufferData(gl.ARRAY_BUFFER,buffer,gl.STATIC_DRAW);
				triangleVertexBuffer.positionSize=3;
				triangleVertexBuffer.colorSize=4;
				triangleVertexBuffer.numberOfItems=3;
			}

			function draw(){
				gl.viewport(0,0,gl.viewportWidth,gl.viewportHeight);
				gl.clear(gl.COLOR_BUFFER_BIT);

				//BIND
				gl.bindBuffer(gl.ARRAY_BUFFER,triangleVertexBuffer);

				//Describe how
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute,triangleVertexBuffer.positionSize,gl.FLOAT,false,16,0);

				gl.vertexAttribPointer(shaderProgram.vertexColorAttribute,triangleVertexBuffer.colorSize,gl.UNSIGNED_BYTE,true,16,12);

				gl.drawArrays(gl.TRIANGLES,0,triangleVertexBuffer.numberOfItems);
			}

			function startup(){
				//get canvas and context
				canvas=document.querySelector('.myCLCanvas');
				gl=WebGLDebugUtils.makeDebugContext(createGLContext(canvas));
				//load cource code into shader and compile
				setupShaders(true);
				setupBuffers();
				//clear color
				gl.clearColor(0.6,  0.4,  0.3,  0.5);
				//connect buffer to shader
				draw();
			}
			document.addEventListener('DOMContentLoaded',function(event){
				startup();
			})
		</script>
		<body>
			<canvas class="myCLCanvas" width="500" height="500"></canvas>
		</body>
	</head>
</html>