<!DOCTYPE HTML>
<html>
	<head>
		<title>Draws a triangle</title>
		<meta charset="utf-8">
		<script src="js/webgl-debug.js"></script>
		<script src="js/shader.js"></script>
		<script src="js/gl-matrix.js"></script>
		<script id="shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec4 aVertexColor;
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			varying vec4 vColor;
			void main(){
				gl_Position=uPMatrix*uMVMatrix*vec4(aVertexPosition,1.0);
				vColor=aVertexColor;
			}
		</script>
		<script id="shader-fs" type="x-shader/x-fragment">
			precision mediump float;
			varying vec4 vColor;
			void main(){
				gl_FragColor=vColor;
			}
		</script>
		<script>
			var gl,canvas,shaderProgram,floorVertexPositionBuffer,floorVertexIndexBuffer,
			cubeVertexPositionBuffer,cubeVertexIndexBuffer,modelViewMatrix,projectionMatrix,
			modelVeiwMatrixStack;

			function setupShaders(){
				var vertexShader=loadShaderFromDOM('shader-vs');
				var fragmentShader=loadShaderFromDOM('shader-fs');

				shaderProgram=gl.createProgram();
				gl.attachShader(shaderProgram,vertexShader);
				gl.attachShader(shaderProgram,fragmentShader);
				gl.linkProgram(shaderProgram);

				if(!gl.getProgramParameter(shaderProgram,gl.LINK_STATUS)){
					console.log('Failed to setup shaders');
				}

				gl.useProgram(shaderProgram);

				shaderProgram.vertexPositionAttribute=gl.getAttribLocation(shaderProgram,'aVertexPosition');
				shaderProgram.vertexColorAttribute=gl.getAttribLocation(shaderProgram,'aVertexColor');
				shaderProgram.uniformMVMatrix=gl.getUniformLocation(shaderProgram,'uMVMatrix');
				shaderProgram.uniformProjMatrix=gl.getUniformLocation(shaderProgram,'uPMatrix');

				gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

				modelViewMatrix=mat4.create();
				projectionMatrix=mat4.create();
				modelViewMatrixStack=[];
			}

			function pushModelViewMatrix(){
				var copyToPush=mat4.clone(modelViewMatrix);
				modelViewMatrixStack.push(copyToPush);
			}

			function popModelViewMatrix(){
				if(modelViewMatrixStack.length==0){
					throw "Error popModelViewMatrix()-Stack was empty";
				}
				modelViewMatrix=modelViewMatrixStack.pop();
			}

			function setupFloorBuffers(){
				var floorVertexPosition = [
				    // Plane in y=0
				    5.0, 0.0, 5.0, //v0
				    5.0, 0.0, -5.0, //v1
				    -5.0, 0.0, -5.0, //v2
				    -5.0, 0.0, 5.0//v3
				]; 
				floorVertexPositionBuffer=bindBuffer(floorVertexPosition,3,4);
				var floorVertexIndices = [0, 1, 2, 3];
				floorVertexIndexBuffer=bindElementArrayBuffer(floorVertexIndices,1,4);
			}

			function setupCubeBuffers(){
				var cubeVertexPosition = [
				    // Front face
				    1.0, 1.0, 1.0, //v0
				    -1.0, 1.0, 1.0, //v1
				    -1.0, -1.0, 1.0, //v2
				    1.0, -1.0, 1.0, //v3

				    // Back face
				    1.0, 1.0, -1.0, //v4
				    -1.0, 1.0, -1.0, //v5
				    -1.0, -1.0, -1.0, //v6
				    1.0, -1.0, -1.0, //v7

				    // Left face
				    -1.0, 1.0, 1.0, //v8
				    -1.0, 1.0, -1.0, //v9
				    -1.0, -1.0, -1.0, //v10
				    -1.0, -1.0, 1.0, //v11

				    // Right face
				    1.0, 1.0, 1.0, //12
				    1.0, -1.0, 1.0, //13
				    1.0, -1.0, -1.0, //14
				    1.0, 1.0, -1.0, //15

				    // Top face
				    1.0, 1.0, 1.0, //v16
				    1.0, 1.0, -1.0, //v17
				    -1.0, 1.0, -1.0, //v18
				    -1.0, 1.0, 1.0, //v19

				    // Bottom face
				    1.0, -1.0, 1.0, //v20
				    1.0, -1.0, -1.0, //v21
				    -1.0, -1.0, -1.0, //v22
				    -1.0, -1.0, 1.0, //v23
				];
				cubeVertexPositionBuffer=bindBuffer(cubeVertexPosition,3,24);
				var cubeVertexIndices = [
		            0, 1, 2, 0, 2, 3, // Front face
		            4, 6, 5, 4, 7, 6, // Back face
		            8, 9, 10, 8, 10, 11, // Left face
		            12, 13, 14, 12, 14, 15, // Right face
		            16, 17, 18, 16, 18, 19, // Top face
		            20, 22, 21, 20, 23, 22 // Bottom face
		        ];
		        cubeVertexIndexBuffer=bindElementArrayBuffer(cubeVertexIndices,1,36);
			}
			function setupBuffers(){
				setupFloorBuffers();
				setupCubeBuffers();
			}

			function uploadModelViewMatrixToShader(){
				gl.uniformMatrix4fv(shaderProgram.uniformMVMatrix,false,modelViewMatrix);
			}

			function uploadProjectionMatrixShader(){
				gl.uniformMatrix4fv(shaderProgram.uniformProjMatrix,false,projectionMatrix);
			}

			function drawFloor(r,g,b,a){
				gl.disableVertexAttribArray(shaderProgram.vertexColorAttribute);
				//Set color
				gl.vertexAttrib4f(shaderProgram.vertexColorAttribute,r,g,b,a);
				//draw the floor
				gl.bindBuffer(gl.ARRAY_BUFFER,floorVertexPositionBuffer);

				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute,
					floorVertexPositionBuffer.itemSize,gl.FLOAT,false,0,0);
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,floorVertexIndexBuffer);
				gl.drawElements(gl.TRIANGLE_FAN,floorVertexIndexBuffer.numberOfItems,
					gl.UNSIGNED_SHORT,0);
				//gl.TRIANGLES  gl.tri
			}


			function drawCube(r,g,b,a){
				gl.disableVertexAttribArray(shaderProgram.vertexColorAttribute);
				//use element array
				//assign color
				gl.vertexAttrib4f(shaderProgram.vertexColorAttribute,r,g,b,a);
				//bind position buffer
				gl.bindBuffer(gl.ARRAY_BUFFER,cubeVertexPositionBuffer);
				//set attrib
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute,cubeVertexPositionBuffer.itemSize,gl.FLOAT,false,0,0);
				//bind index buffer
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,cubeVertexIndexBuffer);
				
				gl.drawElements(gl.TRIANGLES,cubeVertexIndexBuffer.numberOfItems,gl.UNSIGNED_SHORT,0);
			}

			function drawTable(){
				pushModelViewMatrix();
				mat4.translate(modelViewMatrix,modelViewMatrix,[0.0,1.0,0.0]);
				mat4.scalar.scale(modelViewMatrix,modelViewMatrix,[2.0,0.1,2.0]);
				uploadModelViewMatrixToShader();

				drawCube(0.72, 0.53, 0.04, 1.0);
				popModelViewMatrix();

				//Draw table legs
				for(var i=-1;i<=1;i+=2){
					for(var j=-1;j<=1;j+=2){
						pushModelViewMatrix();
						mat4.translate(modelViewMatrix,modelViewMatrix,[i*1.9,-0.1,j*1.9]);
						mat4.scale(modelViewMatrix,modelViewMatrix,[0.1,1.0,0.1]);
						uploadModelViewMatrixToShader();
						drawCube(0.72,0.53,0.04,1.0);
						popModelViewMatrix();
					}
				}
			}

			function draw(){
				gl.viewport(0,0,gl.viewportWidth,gl.viewportHeight);
				gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
				mat4.perspective(projectionMatrix,19.9,gl.viewportWidth/gl.viewportHeight,0.1,100.0);//problem1
				//test
				mat4.identity(modelViewMatrix);
				mat4.lookAt(modelViewMatrix,[8,5,-10],[0,0,0],[0,1,0]);

				uploadModelViewMatrixToShader();
				uploadProjectionMatrixShader();

				//drawFloor
				drawFloor(1.0,0.0,0.0,1.0);

				//draw table
				pushModelViewMatrix();
				mat4.translate(modelViewMatrix,modelViewMatrix,[0.0,1.1,0.0]);
				uploadModelViewMatrixToShader();
				drawTable();
				popModelViewMatrix();

				//draw box on top of the table
				pushModelViewMatrix();
				mat4.translate(modelViewMatrix,modelViewMatrix,[0.0,2.7,0.0]);
				mat4.scale(modelViewMatrix,modelViewMatrix,[0.5,0.5,0.5]);
				uploadModelViewMatrixToShader();
				drawCube(0.0,0.0,1.0,1.0);
				popModelViewMatrix();
			}

			function startup(){
				canvas=document.querySelector('.myGLCanvas');
				gl=WebGLDebugUtils.makeDebugContext(createGLContext(canvas));
				setupShaders();
				setupBuffers();
				gl.clearColor(1.0,1.0,1.0,1.0);
				gl.enable(gl.DEPTH_TEST);

				draw();
			}

			document.addEventListener('DOMContentLoaded',function(event){
				startup();
			})
		</script>
		<body>
			<canvas class="myGLCanvas" width="500" height="500"></canvas>
		</body>
	</head>
</html>