<script>
	//1.4.1
	//a
		//Delete ith Element
		//switch ith element with nth element
		//set lenght as n-1
		//so times costs will always be O(1)
	//b
		//Replace the ith element with a special symbol 
		//that cannot exist inthe data of the array. This 
		//sentinel element must be skipped over whten encountered then processing the array

	//1.4.2
		//a
			//binary search
		//b
			//binary search with linked list
	//1.4.3
		//a
			//a
			//ab
			//a
			//ac
			//acd
			//ac
		//b
			//a
			//ba
			//b
			//cb
			//dcb
			//dc
	//1.4.4
		//a
			//every element of adjacency matrix will be 1
		//b
			//ith row and ith column will be ith
		//c
			//all element of ith row is 0
	//1.4.5
		//INPUT:free tree, root
		//OUPUT:rooted tree
		//1.currentNode<-root
		//2.find all the nodes that are linked with currentNode,they are children of currentNode
		//3.for i in nodes,choose nodes[i] as root,goto 1 
	//1.4.6
		//we have n nodes.arrange two children to a node as much as we can
		//then we get a tree with lowest height,log2n

		//if the tree is like a linked list, then the height is n-1
	//1.4.7
		//a
			//dequeue:iterate elements of the array,find the biggest exchange with the last one,length-1
			//enqueue:add element to the last one,length+1;
		//b
			//enqueue:find position ith elemnt<x<ith element,
				//while(n==i+1)set nth element as n+1th,n--
				//set x as ith element
			//dequeue:


</script>