<script>
	//1.4.1
	//a
		//Delete ith Element
		//switch ith element with nth element
		//set lenght as n-1
		//so times costs will always be O(1)
	//b
		//Replace the ith element with a special symbol 
		//that cannot exist inthe data of the array. This 
		//sentinel element must be skipped over whten encountered then processing the array

	//1.4.2
		//a
			//binary search
		//b
			//binary search with linked list
	//1.4.3
		//a
			//a
			//ab
			//a
			//ac
			//acd
			//ac
		//b
			//a
			//ba
			//b
			//cb
			//dcb
			//dc
	//1.4.4
		//a
			//every element of adjacency matrix will be 1
		//b
			//ith row and ith column will be ith
		//c
			//all element of ith row is 0
	//1.4.5
		//INPUT:free tree, root
		//OUPUT:rooted tree
		//1.currentNode<-root
		//2.find all the nodes that are linked with currentNode,they are children of currentNode
		//3.for i in nodes,choose nodes[i] as root,goto 1 
	//1.4.6
		//we have n nodes.arrange two children to a node as much as we can
		//then we get a tree with lowest height,log2n

		//if the tree is like a linked list, then the height is n-1
	//1.4.7
		//a
			//dequeue:iterate elements of the array,find the biggest exchange with the last one,length-1
			//enqueue:add element to the last one,length+1;
		//b
			//enqueue:find position ith elemnt<x<ith element,
				//while(n==i+1)set nth element as n+1th,n--
				//set x as ith element
			//dequeue:delete the first element,length+1
		//c
			//dequeue:
				//INPUT:node x
				//if node has right child,find node's right child 
				//if not,delete node x,node x's left child as node.
			//enqueue:
				//INPUT:node
				//
				function Node(value,left,right){
					// Node's value
					this.value=value;
					// node's left child
					this.left=null;
					// node's right child
					this.right=null;
					// node's additional value
					this.count=1;
				}
				//enqueue
				function add(node,value){
					// if node is null
					if(node==null){
						node=new Node(value);
						return node;
					}

					// if value is bigger than this node's value
					if(value<node.value){
						if(node.left){
							add(node.left,value);
						}else{
							node.left=new Node(value);
						}
					}

					// if value is smaller than this node's value
					if(value>node.value){
						if(node.right){
							add(node.right,value);
						}else{
							node.right=new Node(value);
						}
					}

					//if value is equal to this node's value
					if(node==node.value){
						node.count++;
						return;
					}
				}

				var arr=[9,5,12,1,7,10,4];
				var root=new Node(arr[0]);
				for(var i=1;i<arr.length;i++){
					add(root,arr[i]);
				}
				// find min
				function findMin(node){
					while(node.left){
						node=node.left;
					}
					return node;
				}
				//dequque
				function dequeue(){
					var max=root;
					var parent=max;
					while(max.right){
						parent=max;
						max=max.right;
					}
					var value=max.value;
					if(max==root){
						root=max.left;
					}else if(max.left){
						var l=max.left;
						max.value=l.value;
						max.left=l.left;
						max.right=l.right;
						delete l;
					}else{
						delete parent.right;
					}
					return value;
				}
				//dequeue
				function deleteNode(value,node){
					if(node==null){
						return null;
					}
					// if node's value is bigger than value
					if(node.value>value){
						dequeue(value,node.left);
					}
					// if node's value is smaller than value
					if(node.value<value){
						dequeue(value,node.right);
					}

					if(node.value==value){
						// if there's two same elements,decrease count
						if(node.count!=1){
							node.count--;
						}else{
							// if this node has two children
							if(node.right&&node.left){
								var parent=node,succ=node.right;
								while(succ.left){
									parent=succ;
									succ=succ.left;
								}
								node.value=succ.value;
								//if succ doesn't have left child
								// parent will equal to node
								if(parent==node){
									parent.right=succ.right;
								}else if(parent!=node){
									parent.left=succ.right;
								}
							}else if(!node.right&&!node.left){
								delete node;
							}else if(node.right&&!node.left){
								var r=node.right;
								node.value=node.right.value;
								node.right=r.right;
								node.left=r.left;
								delete r;
							}else if(node.left&&!node.right){
								var l=node.left;
								node.value=node.left.value;
								node.right=l.right;
								node.left=l.left;
								delete l;
							}
						}
						return true;
					}
				}


	//1.4.8
		//Dictionary
			//Insert
				//i=1,get value's first i character as key
				//if key is already exist,i++,use first i++ charater as key
				//insert to a key
			//Delete
				//i=1,get value's first i character as key
				//if key is already exist,i++,use first i++ chareter as key
				//if found,delete
	//1.4.9
		//a priority queue
		//b queue
		//c stack
	//1.4.10
		//INPUT: str1,str2
		//OUTPUT: BOOLEAN
		//1.iterate: for i in str1
		//2.if(!map[i])map[i]++
		//3.if(map[i])map[i]=1
		//4.i++,if i=str1.length break,else goto 1
		//do the samething to str2 return a map2
		//compare map2 with map1
		//if they are same as each other,return true,else return false

</script>