图
	图论相关
	搜索问题简介
	BFS
	DFS
定义
	节点
	边
分类
	有向，无向，有权，无权
相关问题
	搜索
		dfs/bfs
	连通性
		连通分量
		割点，割边
	最短路
		单源
		任意两点
	最小生成树
	拓扑排序
	网络流
	匹配
图的表示
	邻接矩阵
		缺点
			无法表示重边
			稀疏图浪费空间
			不能直接得到一个节点的度
	邻接表
		缺点
			不能知道i,j是否有边
搜索
	建立一个图 
		定义节点，定义边
	定义起点和终点
	找到路径
		判断是否有解
		找到全部解
		找到满足条件的某种解

BFS
	假设在图的某点，如何搜索一条路
		从起点开始标记距离为1的点
		从距离为1的点开始，继续标记和节点距离为2的店
		d-->d+1
	Breadth First Search
		基本框架 队列里始终是距离为d的点
			队列放入起点，标记起点
			while(队列非空)
				x出队
				扩展x，对每个x的后裔y,如果y没被标记
					y是距离起点为(d+1)的店
					标记y并入队
		为什么要标记
			防止重复入队--‘转圈’，死循环。只有第一次到达的谋个点是有效的
		标记什么
			简单bool,true
			记录距离：从起点经过多少步到达这里
			记录上一个节点
		理解bfs
			以起点为中心，一层一层向外扩散
			所有边权权为1的最短路问题
			还原/存储路径麻烦
			使用数据结构；队列
	例
		搜索树，指数增长
		双向BFS
			切半思想
			如果，属高度为h，需要搜索的节点数dexh
			从起点正想，从起点反向
				理想情况可以做到(2d)h/2
			本质
				不要让树太高，越高的树一般越宽
			实现：两个队列
				起点，重点各搜一步
				每次优先扩展较小的队列
DSF
	从起点一路走到低，无路可走，退回上一部
	Depth First Search
		基本框架，堆栈
			堆栈里放入起点
			while非空
				堆栈顶x还有没经过的节点y，压入y
				否则x出栈
	理解DFS
		从起点为中心，深入扩展
			能深入一步就深入一步
			不能深入一步，退回上一个节点
		还原/存储路径容易
DFS改进
	枚举解得深度
		每次接到深度DFS

最短路径算法简介
	dijkstra
		边权>=0
		单元
		关键
			如何记录最短路径
			组合记录最短路径有多少条
	任意两点间最短路floyd-warshall
		边权任意，汇报负圈
	任意边权最短路bellman-ford
		边权任意，汇报负圈

最小生成树
	书
		无向无环连通图
		n歌节点恰好有(n-1)条边
	生成树
		节点：（连通）图的全部节点
		边：原来图边的子集
	最小生成树
		所有生成树中，边权和最小

Prim算法描述
	维护完整的一棵树
Kruskal
	从来不维护生成树

拓扑排序
	输出对象
		DAG
	输出
		节点的一个顺序
	算法描述

欧拉回路与汉密尔顿回路
	经过所有仅以此的回路

例7
例8
	给定课程依赖关系
		问是否存在合法的选课顺序

例9
	给定一个棋盘，只能走方向和竖直方向
	转换存储，汉密尔顿路欧尔可以转换为欧拉路
例10
	滑块儿
	一般建图
		节点0000-0000
		边：a的后四位和b的前4位相等
	转换
		节点：三位数字000-999
例11
	x指向v1么

常见问题
	强连通分量
	搜索
	最短路
	最小生成树
短视频