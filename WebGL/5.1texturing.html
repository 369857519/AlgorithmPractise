<!DOCTYPE HTML>
<html>
	<head>
		<title>Draws a triangle</title>
		<meta charset="utf-8">
		<script src="js/webgl-debug.js"></script>
		<script src="js/shader.js"></script>
		<script src="js/gl-matrix.js"></script>
		<script id="shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec4 aVertexColor;
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			varying vec4 vColor;
			void main(){
				gl_Position=uPMatrix*uMVMatrix*vec4(aVertexPosition,1.0);
				vColor=aVertexColor;
			}
		</script>
		<script id="shader-fs" type="x-shader/x-fragment">
			precision mediump float;
			varying vec4 vColor;
			void main(){
				gl_FragColor=vColor;
			}
		</script>
		<script>
			var gl,canvas;

			//shader and texture
			var pwgl={
				ongoingImageLoads:[],
				floorVertexPositionBuffer:{},
				cubeVertexPositionBuffer:{},
				cubeVertexIndexBuffer:{},
				modelViewMatrix:{},
				projectionMatrix:{},
				modelVeiwMatrixStack:{}
			}

			function setupShaders(){
				var vertexShader=loadShaderFromDOM('shader-vs');
				var fragmentShader=loadShaderFromDOM('shader-fs');

				var shaderProgram=gl.createProgram();
				gl.attachShader(shaderProgram,vertexShader);
				gl.attachShader(shaderProgram,fragmentShader);
				gl.linkProgram(shaderProgram);

				if(!gl.getProgramParameter(shaderProgram,gl.LINK_STATUS)){
					console.log('Failed to setup shaders');
				}

				gl.useProgram(shaderProgram);

				pwgl.vertexPositionAttributeLoc=gl.getAttribLocation(shaderProgram,'aVertexPosition');
				pwgl.vartexTextureAttributeLoc=gl.getAttribLocation(shaderProgram,'aVertexColor');
				pwgl.uniformMVMatrixLoc=gl.getUniformLocation(shaderProgram,'uMVMatrix');
				pwgl.uniformProjMatrixLoc=gl.getUniformLocation(shaderProgram,'uPMatrix');
				pwgl.uniformSamplerLoc=gl.getUniformLocation(shaderProgram,'uSampler');

				gl.enableVertexAttribArray(pwgl.vertexPositionAttributeLoc);
				gl.enableVertexAttribArray(pwgl.vertexTextureAttributeLoc);

				pwgl.modelViewMatrix=mat4.create();
				pwgl.projectionMatrix=mat4.create();
				pwgl.modelViewMatrixStack=[];
			}

			function pushModelViewMatrix(){
				var copyToPush=mat4.clone(pwgl.modelViewMatrix);
				pwgl.modelViewMatrixStack.push(copyToPush);
			}

			function popModelViewMatrix(){
				if(pwgl.modelViewMatrixStack.length==0){
					throw "Error popModelViewMatrix()-Stack was empty";
				}
				pwgl.modelViewMatrix=pwgl.modelViewMatrixStack.pop();
			}

			function setupFloorBuffers(){
				pwgl.floorVertexPositionBuffer=gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER,pwgl.floorVertexPositionBuffer);
				//position
				var floorVertexPosition = [
				    // Plane in y=0
				    5.0, 0.0, 5.0, //v0
				    5.0, 0.0, -5.0, //v1
				    -5.0, 0.0, -5.0, //v2
				    -5.0, 0.0, 5.0//v3
				]; 

				gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(floorVertexPosition),gl.STATIC_DRAW);

				pwgl.FLOOR_VERTEX_POS_BUF_ITEM_SIZE=3;
				pwgl.FLOOR_VERTEX_POS_BUF_NUM_ITEMS=4;

				//texture buffer
				pwgl.floorVertexTextureCoordinateBuffer=gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER,pwgl.floorVertexTextureCoordinateBuffer);
				var floorVertexTextureCoordinates=[
					2.0,0.0,
					2.0,2.0,
					0.0,2.0,
					0.0,0.0
				];
				gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(floorVertexTextureCoordinates),gl.STATIC_DRAW);

				pwgl.FLOOR_VERTEX_TEX_BUF_ITEM_SIZE=2;
				pwgl.FLOOR_VERTEX_TEX_BUF_NUM_ITEMS=4;

				//
				pwgl.floorVertexIndexBuffer=gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,pwgl.floorVertexIndexBuffer);
				var floorVertexIndeces=[0,1,2,3];

				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(floorVertexIndeces),gl.STATIC_DRAW);

				pwgl.FLOOR_VERTEX_INDEX_BUF_ITEM_SIZE=1;
				pwgl.FLOOR_VERTEX_INDEX_BUF_NUM_SIZE=4;


			}

			function setupCubeBuffers(){
				pwgl.cubeVertexPositionBuffer=gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER,pwgl.cubeVertexPositionBuffer);
				//cubePosition
				var cubeVertexPosition = [
				    // Front face
				    1.0, 1.0, 1.0, //v0
				    -1.0, 1.0, 1.0, //v1
				    -1.0, -1.0, 1.0, //v2
				    1.0, -1.0, 1.0, //v3

				    // Back face
				    1.0, 1.0, -1.0, //v4
				    -1.0, 1.0, -1.0, //v5
				    -1.0, -1.0, -1.0, //v6
				    1.0, -1.0, -1.0, //v7

				    // Left face
				    -1.0, 1.0, 1.0, //v8
				    -1.0, 1.0, -1.0, //v9
				    -1.0, -1.0, -1.0, //v10
				    -1.0, -1.0, 1.0, //v11

				    // Right face
				    1.0, 1.0, 1.0, //12
				    1.0, -1.0, 1.0, //13
				    1.0, -1.0, -1.0, //14
				    1.0, 1.0, -1.0, //15

				    // Top face
				    1.0, 1.0, 1.0, //v16
				    1.0, 1.0, -1.0, //v17
				    -1.0, 1.0, -1.0, //v18
				    -1.0, 1.0, 1.0, //v19

				    // Bottom face
				    1.0, -1.0, 1.0, //v20
				    1.0, -1.0, -1.0, //v21
				    -1.0, -1.0, -1.0, //v22
				    -1.0, -1.0, 1.0, //v23
				];

				gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(cubeVertexPosition),gl.STATIC_DRAW);

				pwgl.CUBE_VERTEX_POS_BUF_ITEM_SIZE=3;
				pwgl.CUBE_VERTEX_POS_BUF_NUM_ITEMS=24;

				//cube texture
				pwgl.cubeVertexTextureCoordinateBuffer=gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER,pwgl.cubeVertexTextureCoordinateBuffer);

				var textureCoordinates=[
					//Front face
					0.0,0.0,
					1.0,0.0,
					1.0,1.0,
					0.0,1.0,

					//back face
					0.0,1.0,
					1.0,1.0,
					1.0,0.0,
					0.0,0.0,

					//left face
					0.0,1.0,
					1.0,1.0,
					1.0,0.0,
					0.0,0.0,

					//right face
					0.0,1.0,
					1.0,1.0,
					1.0,0.0,
					0.0,0.0,

					//top face
					0.0,1.0,
					1.0,1.0,
					1.0,0.0,
					0.0,0.0,

					//bottom face
					0.0,1.0,
					1.0,1.0,
					1.0,0.0,
					0.0,0.0
				];
				gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(textureCoordinates),gl.STATIC_DRAW);
				pwgl.CUBE_VERTEX_COORD_BUF_ITEM_SIZE=2;
				pwgl.CUBE_VERTEX_TEX_COORD_BUF_NUM_ITEMS=24;


				//vertex buffer
				pwgl.cubeVertexIndexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pwgl.cubeVertexIndexBuffer);
				var cubeVertexIndices = [
				    0, 1, 2, 0, 2, 3, // Front face
				    4, 6, 5, 4, 7, 6, // Back face
				    8, 9, 10, 8, 10, 11, // Left face
				    12, 13, 14, 12, 14, 15, // Right face
				    16, 17, 18, 16, 18, 19, // Top face
				    20, 22, 21, 20, 23, 22 // Bottom face
				];
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices),
				    gl.STATIC_DRAW);
				pwgl.CUBE_VERTEX_INDEX_BUF_ITEM_SIZE = 1;
				pwgl.CUBE_VERTEX_INDEX_BUF_NUM_ITEMS = 36;
			}

			function textureFinishedLoading(image,texture){
				gl.bindTexture(gl.TEXTURE_2D,texture);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true);

				gl.texImage2D(gl.TEXTURE_2D,0,gl.RGEA,gl.RGBA,gl.UNFIGNED_BYTE,image);

				gl.generateMipmap(gl.TEXTURE_2D);

				gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAT_FILTER,gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);

				gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.MIRRORED_REPEAT);
				gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.MIRRORED_REPEAT);

				gl.bindTexture(gl.TEXTURE_2D,null);
			}

			function loadImageForTexture(url,texture){
				var image=new Image();
				image.onload=function(){
					pwgl.ongoingImageLoads.splice(pwgl.ongoingImageLoads.indexOf(image),1);
					textureFinishedLoading(image,texture);
				}
				pwgl.ongoingImageLoads.push(image);
				image.src=url;
			}

			function setupTextures(){
				// Texture for the table
				pwgl.woodTexture = gl.createTexture();
				loadImageForTexture("examples/Listing-5-1/wood_128x128.jpg", pwgl.woodTexture);

				// Texture for the floor
				pwgl.groundTexture = gl.createTexture();
				loadImageForTexture("examples/Listing-5-1/wood_floor_256.jpg", pwgl.groundTexture);

				// Texture for the box on the table
				pwgl.boxTexture = gl.createTexture();
				loadImageForTexture("examples/Listing-5-1/wicker_256.jpg", pwgl.boxTexture);
			}

			function setupBuffers(){
				setupFloorBuffers();
				setupCubeBuffers();
			}

			function uploadModelViewMatrixToShader(){
				gl.uniformMatrix4fv(pwgl.uniformMVMatrix,false,pwgl.modelViewMatrix);
			}

			function uploadProjectionMatrixShader(){
				gl.uniformMatrix4fv(pwgl.uniformProjMatrix,false,pwgl.projectionMatrix);
			}

			function drawFloor(texture){
				// Draw the floor
				//bind vertex buffer
				gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.floorVertexPositionBuffer);
				gl.vertexAttribPointer(pwgl.vertexPositionAttributeLoc,
				    pwgl.FLOOR_VERTEX_POS_BUF_ITEM_SIZE,
				    gl.FLOAT, false, 0, 0);
				//bind texture position buffer
				gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.floorVertexTextureCoordinateBuffer);
				gl.vertexAttribPointer(pwgl.vertexTextureAttributeLoc,
				    pwgl.FLOOR_VERTEX_TEX_COORD_BUF_ITEM_SIZE,
				    gl.FLOAT, false, 0, 0);
				//bind texture image buffer
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, pwgl.groundTexture);
				//bind element indeces buffer
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pwgl.floorVertexIndexBuffer);
				gl.drawElements(gl.TRIANGLE_FAN, pwgl.FLOOR_VERTEX_INDEX_BUF_NUM_ITEMS,
				    gl.UNSIGNED_SHORT, 0);
			}


			function drawCube(texture){
				gl.bindBuffer(gl.ARRAY_BUFFER, pwgl.cubeVertexPositionBuffer);
				gl.vertexAttribPointer(pwgl.vertexPositionAttributeLoc,
				    pwgl.CUBE_VERTEX_POS_BUF_ITEM_SIZE,
				    gl.FLOAT, false, 0, 0);
				//texture coord
				gl.bindBuffer(gl.ARRAY_BUFFER,pwgl.cubeVertexTextureCoordinateBuffer);
				gl.vertexAttribPointer(pwgl.vertexTextureAttributeLoc,pwgl.CUBE_VERTEX_TEX_COORD_BUF_NUM_ITEMS,gl.FLOAT,false,0,0);
				//
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D,texture);

				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pwgl.cubeVertexIndexBuffer);

				gl.drawElements(gl.TRIANGLES, pwgl.CUBE_VERTEX_INDEX_BUF_NUM_ITEMS,
				    gl.UNSIGNED_SHORT, 0);
			}

			function drawTable(){
				pushModelViewMatrix();
				mat4.translate(pwgl.modelViewMatrix,pwgl.modelViewMatrix,[0.0,1.0,0.0]);
				mat4.scalar.scale(pwgl.modelViewMatrix,pwgl.modelViewMatrix,[2.0,0.1,2.0]);
				uploadModelViewMatrixToShader();
				//
				drawCube(pwgl.woodTexture);
				popModelViewMatrix();

				//Draw table legs
				for(var i=-1;i<=1;i+=2){
					for(var j=-1;j<=1;j+=2){
						pushModelViewMatrix();
						mat4.translate(pwgl.modelViewMatrix,pwgl.modelViewMatrix,[i*1.9,-0.1,j*1.9]);
						mat4.scale(pwgl.modelViewMatrix,pwgl.modelViewMatrix,[0.1,1.0,0.1]);
						uploadModelViewMatrixToShader();
						drawCube(pwgl.woodTexture);
						popModelViewMatrix();
					}
				}
			}

			function draw(){
				gl.viewport(0,0,gl.viewportWidth,gl.viewportHeight);
				gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
				mat4.perspective(pwgl.projectionMatrix,19.9,gl.viewportWidth/gl.viewportHeight,0.1,100.0);//problem1
				//test
				mat4.identity(pwgl.modelViewMatrix);
				mat4.lookAt(pwgl.modelViewMatrix,[8,5,-10],[0,0,0],[0,1,0]);

				uploadModelViewMatrixToShader();
				uploadProjectionMatrixShader();
				gl.uniform1i(pwgl.uniformSamplerLoc,0);

				//drawFloor
				drawFloor(1.0,0.0,0.0,1.0);

				//draw table
				pushModelViewMatrix();
				mat4.translate(pwgl.modelViewMatrix,pwgl.modelViewMatrix,[0.0,1.1,0.0]);
				uploadModelViewMatrixToShader();
				drawTable();
				popModelViewMatrix();

				//draw box on top of the table
				pushModelViewMatrix();
				mat4.translate(pwgl.modelViewMatrix,pwgl.modelViewMatrix,[0.0,2.7,0.0]);
				mat4.scale(pwgl.modelViewMatrix,pwgl.modelViewMatrix,[0.5,0.5,0.5]);
				uploadModelViewMatrixToShader();
				drawCube(pwgl.boxTexture);
				popModelViewMatrix();

				pwgl.requestId=requestAnimFrame(draw,canvas);
			}

			function handleContextLost(event){
				event.preventDefault();
				cancelRequestAnimFram(pwgl.requestId);

				//Ignore all ongoing image loads
				for(var i=0;i<pwgl.ongoingImageLoads.length;i++){
					pwgl.ongoingImageLoads[i].onload=undefined;
				}
				pwgl.ongoingImageLoads=[];
			}

			function handleContextRestored(event){
				setupShaders();
				setupBuffers();
				setupTextures();
				gl.clearColor(0.0,0.0,0.0,1.0);
				gl.enable(gl.DEPTH_TEST);
				pwgl.requestId=requestAnimFrame(draw,canvas);
			}

			function startup(){
				canvas=document.querySelector('.myGLCanvas');
				gl=WebGLDebugUtils.makeDebugContext(createGLContext(canvas));
				//
				canvas.addEventListener('weglcontextlost',handleContextLost,false);
				canvas.addEventListener('webglcontextrestored',handleContextRestored,false);
				//
				setupShaders();
				setupBuffers();
				setupTextures();

				gl.clearColor(1.0,1.0,1.0,1.0);
				gl.enable(gl.DEPTH_TEST);

				draw();
			}

			document.addEventListener('DOMContentLoaded',function(event){
				startup();
			})
		</script>
		<body>
			<canvas class="myGLCanvas" width="500" height="500"></canvas>
		</body>
	</head>
</html>